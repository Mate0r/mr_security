<?php
/**
* 2007-2022 MaTe0r
*
*  MODULE mr_security
*
*  @author    MaTe0r <mateo.rinaldi.pro@gmail.com>
*  @copyright MaTe0r
*  @license   http://opensource.org/licenses/afl-3.0.php  Academic Free License (AFL 3.0)
*
*/

if (!defined('_PS_VERSION_')) {
    exit;
}

class MrSecurityVulnerability
{
    public $title;
    public $cve_id;
    public $url;
    public $product;
    public $cve_html;
    public $category;

    const STATUS_NOT_IMPACTED = 0;
    const STATUS_NOT_VULNERABLE = 1;
    const STATUS_VULNERABLE = 2;
    const STATUS_UNKNOWN = 3;

    const FRIENDS_OF_PRESTA_API = "https://security.friendsofpresta.org/search.json";


    public static function getJSONFile()
    {
        if (!$jsonString = file_get_contents(static::FRIENDS_OF_PRESTA_API)) {
            throw new Exception("can't get vulnerabilities through API url ".static::FRIENDS_OF_PRESTA_API.": file_get_contents() failed");
        }

        if (!$json = json_decode($jsonString)) {
            throw new Exception("can't get vulnerabilities through API url : ".static::FRIENDS_OF_PRESTA_API);
        }

        $vulnerabilities = [];
        foreach ($json as $jsonObject) {

            // transform object to vulnerability
            $vulnerability = new static();
            foreach (get_object_vars($jsonObject) as $key => $value) {
                $vulnerability->$key = $value;
            }

            // get the HTML content of CVE page
            $vulnerability->cve_html = file_get_contents($vulnerability->getCVELink());

            // get CVE ID label
            // $pattern = '/<div class="post-content e-content" itemprop="articleBody">.*?<li><strong>CVE ID<\/strong>: (.*?)<\/li>/s';
            // preg_match($pattern, $vulnerability->cve_html, $matches);
            // $vulnerability->cve_id = isset($matches[1]) ? $matches[1] : '?';

            // get the CVE ID
            preg_match('/\[([^]]+)\]/', $vulnerability->title, $matches);
            $vulnerability->cve_id = isset($matches[1]) ? $matches[1] : '?';
            
            // get Product label
            $pattern = '/<div class="post-content e-content" itemprop="articleBody">.*?<li><strong>Product<\/strong>: (.*?)<\/li>/s';
            preg_match($pattern, $vulnerability->cve_html, $matches);
            $vulnerability->product = isset($matches[1]) ? $matches[1] : '?';

            // add vuln to array
            $vulnerabilities[] = $vulnerability;
        }

        file_put_contents(MR_SECURITY_PATH."/download/search_".date('Y_m_d').".json", json_encode($vulnerabilities));
        return true;
    }


    public static function all()
    {
        if (!is_file(MR_SECURITY_PATH."/download/search_".date('Y_m_d').".json") && !static::getJSONFile()) {
            throw new Exception("getJSONFile() failed");
        }

        if (!$json = json_decode(file_get_contents(MR_SECURITY_PATH."/download/search_".date('Y_m_d').".json"))) {
            throw new Exception("can't get vulnerabilities through API url : ".static::FRIENDS_OF_PRESTA_API);
        }

        $vulnerabilities = [];
        foreach ($json as $jsonObject) {

            // transform object to vulnerability
            $vulnerability = new static();
            foreach (get_object_vars($jsonObject) as $key => $value) {
                $vulnerability->$key = $value;
            }

            // add vuln to array
            $vulnerabilities[] = $vulnerability;
        }

        return $vulnerabilities;
    }


    public static function find(string $vulnerability_cve_id)
    {
        foreach (static::all() as $vulnerability) {
            if ($vulnerability->cve_id === $vulnerability_cve_id) {
                return $vulnerability;
            }
        }
        return false;
    }


    public function getCVELink()
    {
        return "https://security.friendsofpresta.org".$this->url;
    }


    public function getLink(string $action = "verify")
    {
        return Context::getContext()->link->getAdminLink("MrSecurityConfigAdmin")."&action=".$action."&vulnerability_cve_id=".$this->cve_id;
    }


    public function getPatch()
    {
        if (!file_exists(MR_SECURITY_PATH."/patchs.json")) {
            return false;
        }

        if (!$jsonString = file_get_contents(MR_SECURITY_PATH."/patchs.json")) {
            return false;
        }

        if (!$json = (array)json_decode($jsonString)) {
            return false;
        }

        if (!isset($json[$this->cve_id])) {
            return false;
        }

        return $json[$this->cve_id];
    }


    public function getStatus()
    {
        if (!$patch = $this->getPatch()) {
            return static::STATUS_UNKNOWN;
        }


        if (in_array($this->category, ["module", "modules"])) {

            try {

                if (!Validate::isModuleName($this->product)) {
                    return static::STATUS_UNKNOWN;
                }

                # check module exists
                if (!$module = Module::getInstanceByName($this->product)) {
                    return static::STATUS_NOT_IMPACTED;
                }

            } catch(Exception $ex) {

                return static::STATUS_NOT_IMPACTED;

            }
            

            # check module version
            if (
                version_compare($module->version, $patch->version_min, '<')
                || version_compare($module->version, $patch->version_max, '>')
            ) {
                return static::STATUS_NOT_VULNERABLE;
            }
        }


        foreach ($patch->files as $fileName => $texts) {

            if (in_array($this->category, ["module", "modules"])) {
                $filePath = _PS_MODULE_DIR_.$this->product.$fileName;
            } else {
                $filePath = _PS_ROOT_DIR_.$fileName;
            }

            foreach ($texts->text_to_match as $key => $text_to_match) {
                
                if ($patch->action === "remove") {
                    return file_exists($filePath) ? static::STATUS_VULNERABLE : static::STATUS_NOT_VULNERABLE;
                } else if ($patch->action === "replace") {
                    return file_exists($filePath) && strpos(file_get_contents($filePath), $text_to_match) !== false ? static::STATUS_VULNERABLE : static::STATUS_NOT_VULNERABLE;
                }

            }
        }
    
        
        return static::STATUS_NOT_VULNERABLE;
    }


    public function patch()
    {
        if (!$patch = $this->getPatch()) {
            return false;
        }
        
        if ($this->category === "modules") {
            $filePath = _PS_MODULE_DIR_.$this->product.$patch->filename;
        } else {
            $filePath = _PS_ROOT_DIR_.$patch->filename;
        }


        if ($patch->action === "replace") {

            if (!$fileContent = file_get_contents($filePath)) {
                return false;
            }

            if (!file_put_contents($filePath, str_replace($patch->text_match, $patch->text_replace, $fileContent))) {
                return false;
            }

        } else if ($patch->action === "remove") {

        }

        return true;
    }
}